"use strict";

// ## MISC
//
// project.mimetype          → "application/x-wanadev-project"
// project.fileExt           → "wprj"
// project.wprjOptions       → {type: "GENERIC", metadataFormat: 1, projectFormat: 1, blogIndexFormat: 1}
// project.metadata          → wprj metadata
// project.newEmptyProject(metadata)
//
// ## LAYERS
//
// project.addLayer(layerName, layerName, ...)
// project.addLayer([layerName, layerName, ...])
// project.removeLayer(layerName, layerName, ...)
// project.removeLayer([layerName, layerName, ...])   // /!\ rm contained structures!
// project.getLayer(name)    → [Structure]
// project.layers            → {layerName: []}
// project.layers.layerName  → [Structure]
//
// ## LAYERS
//
// project.structures        → {id: Structure}
// project.addStructure(structure, layerName)   // Create layer if not exists
// project.removeStrucutre(structure)
// project.removeStructure(structureId)
//
// ## SAVE
//
// project.saveAsBuffer()    → Buffer
// project.saveAsBlob()      → Blob
// project.saveAsData64Url() → String
// TODO project.saveToLocalFile(fileName)          // default: project.wprj
//
// ## OPEN
//
// project.openFromBuffer(project)
// project.openFromBlob(project, callback)
// project.openFormData64Url(project)
// TODO project.openFromLocalFile()
// TODO project.openFromUrl(url, callback)        // PROXY!
//
// TODO ## BLOBS
//
// options = {
//     id: String,       // optional, default: autogenerated uuid
//     mime: String,     // optional, default: "application/octet-stream
//     metadata: {},     // optional, default: {}
//
//     // Extended option for fromImage
//     imageFormat: null|"png"|"jpeg"   (null keep the original format if possible, else it generates a png)
//     imageQuality: Number    (for jpeg only, default = 0.9)
// }
// project.addBlobFromBuffer(buffer, options)       → id: String
// project.addBlob(blob, callback, options)         → function(error, id) {}
// project.addBlobFromData64Url(data64, options)    → id: String
// project.addBlobFromImage(image, options)         → id: String
// project.addBlobFromUrl(url, callback, options)   → function(error, id)   // ? PROXY!
//
// project.getBlob(id)                    → Blob
// project.getBlobAsBuffer(id)            → Buffer
// project.getBlobAsData64Url(id)         → String
// project.getBlobAsImage(id, callback)   → function(error, image) {}
// project.getBlobUrl(id)                 → String
//
// project.getBlobMetadata(id)            → {}
// proejct.removeBlob(id)
// project.blobExists(id) → Boolean
// project.getBlobList() → Array
//
//
// TODO Canvas
// TODO DEFAULT METADATA {version: String, uuid: String, creationDate: Number, lastModification: Number}
// TODO History
// TODO Versioning
// TODO Local Save (localStorage + IndexedDB)
// TODO Move structure to front/back

var WProjectFile = require("wanadev-project-format");
var uuid = require("uuid");

var SerializableClass = require("./SerializableClass.js");
var Structure = require("./Structure.js");
var helpers = require("./helpers.js");

var ProjectManager = SerializableClass.$extend({
    __name__: "Project",

    __init__: function(params) {
        this.$data.mimetype = WProjectFile.MIMETYPE;
        this.$data.fileExt = "wprj";
        this.$data.wprjOptions = {
            metadataFormat: 1,
            projectFormat: 1,
            blobIndexFormat: 1
        };
        this.$data.layers = {};
        this.$data.structures = {};
        this.$data.blobCache = {};   // {uuid: {blob: Blob, url: String}}

        this.newEmptyProject();
        this.$super(params);
    },

    getMimetype: function() {
        "@serializable false";
        return this.$data.mimetype;
    },

    setMimetype: function(mimetype) {
        this.$data.mimetype = mimetype;
    },

    getFileExt: function() {
        "@serializable false";
        return this.$data.fileExt;
    },

    setFileExt: function(ext) {
        this.$data.fileExt = ext;
    },

    getWprjOptions: function() {
        "@serializable false";
        var options = {
            type: this.$data.wprjFile.type,
            metadataFormat: this.$data.wprjOptions.metadataFormat,
            projectFormat: this.$data.wprjOptions.projectFormat,
            blobIndexFormat: this.$data.wprjOptions.blobIndexFormat
        };
        // HACK: apply changes made to the object if the dev do something like `project.wprjOptions.type = "FOO"`...
        setTimeout(function() {
            this.setWprjOptions(options);
        }.bind(this), 0);
        return options;
    },

    setWprjOptions: function(options) {
        if (options.type) {
            this.$data.wprjFile.type = options.type;
        }
        for (var k in options) {
            if (this.$data.wprjOptions[k] !== undefined) {
                this.$data.wprjOptions[k] = options[k];
            }
        }
    },

    getMetadata: function() {
        "@serializable false";
        return this.$data.wprjFile.metadata;
    },

    setMetadata: function(metadata) {
        this.$data.wprjFile.metadata = metadata;
    },

    newEmptyProject: function(metadata) {
        var wprjFile = new WProjectFile();
        if (this.$data.wprjFile) {
            wprjFile.type = this.$data.wprjFile.type;
            this._clean();
        }
        if (metadata) {
            wprjFile.metadata = metadata;
        }
        this.$data.wprjFile = wprjFile;
    },

    getLayers: function() {
        return this.$data.layers;
    },

    addLayers: function(/* *args */) {
        function _add(project, layerName) {
            project.$data.layers[layerName] = project.$data.layers[layerName] || [];
        }
        for (var i = 0 ; i < arguments.length ; i++) {
            if (Array.isArray(arguments[i])) {
                for (var j = 0 ; j < arguments[i].length ; j++) {
                    _add(this, arguments[i][j]);
                }
            } else {
                _add(this, arguments[i]);
            }
        }
    },

    /**
     * Remove given layers and destroy all structures they contain.
     */
    removeLayers: function(/* *args */) {
        function _remove(project, layerName) {
            if (project.$data.layers[layerName]) {
                for (var i = 0 ; i < project.$data.layers[layerName].length ; i++) {
                    project.$data.layers[layerName][i].destroy();
                }
                delete project.$data.layers[layerName];
            }
        }
        for (var i = 0 ; i < arguments.length ; i++) {
            if (Array.isArray(arguments[i])) {
                for (var j = 0 ; j < arguments[i].length ; j++) {
                    _remove(this, arguments[i][j]);
                }
            } else {
                _remove(this, arguments[i]);
            }
        }
    },

    /**
     * Get a layer by name.
     *
     * @return {Array} the requested layer or an empty Array if the layer does not exist.
     */
    getLayer: function(layerName) {
        return this.$data.layers[layerName] || [];
    },

    getStructures: function() {
        return this.$data.structures;
    },

    addStructure: function(structure, layerName) {
        layerName = layerName || "default";
        var structureId;
        if (this.$data.structures[structure.id]) {
            this.removeStructure(structure);
        }
        structure.$data._project = this;
        structure.$data._layerName = layerName;
        this.$data.structures[structure.id] = structure;
        this.addLayers(layerName);
        this.$data.layers[layerName].push(structure);
    },

    removeStructure: function(structure) {
        structure = (structure instanceof Structure) ? structure : this.$data.structures[structure];
        structure.layer.splice(structure.layer.indexOf(structure), 1);
        delete this.$data.structures[structure.id];
        structure.$data._project = undefined;
        structure.$data._layerName = undefined;
    },

    saveAsBuffer: function() {
        this.$data.wprjFile.project = this.serialize();
        return this.$data.wprjFile.exportAsBlob();
    },

    saveAsData64Url: function() {
        return "data:" + this.mimetype + ";base64," + this.saveAsBuffer().toString("base64");
    },

    saveAsBlob: function() {
        return helpers.createBlob([this.saveAsBuffer().toArrayBuffer()], {type: this.mimetype});
    },

    saveToLocalFile: function(filename) {
        filename = filename || "project." + this.fileExt;
        throw new Error("NotImplementedError");  // TODO
    },

    openFromBuffer: function(buffer) {
        if (!WProjectFile.isWanadevProjectFile(buffer)) {
            throw new Error("UnvalidProject");
        }
        var wprjFile = new WProjectFile(buffer);
        this._clean();
        this.$data.wprjFile = wprjFile;
        this.unserialize(wprjFile.project);
    },

    openFromData64Url: function(data64) {
        if (data64.split(":")[0] !== "data") {
            throw new Error("UnvalidProject");
        }
        var buffer = new Buffer(data64.split(",")[1], "base64");
        this.openFromBuffer(buffer);
    },

    openFromBlob: function(blob, callback) {
        var this_ = this;
        var reader = new FileReader();
        reader.onload = function(event) {
            try {
                var buffer = new Buffer(event.target.result);
                this_.openFromBuffer(buffer);
                callback();
            } catch (error) {
                callback(error);
            }
        };
        reader.onerror = callback;
        reader.readAsArrayBuffer(blob);
    },

    openFromLocalFile: function(callback) {
        setTimeout(function() {
            callback(new Error("NotImplementedError"));    // FIXME
        }, 0);
    },

    addBlob: function(buffer, callback, options) {
        setTimeout(function() {
            callback(new Error("NotImplementedError"));    // FIXME
        }, 0);
    },

    addBlobFromBuffer: function(buffer, options) {
        options = options || {};
        var id = options.id || uuid.v4();
        if (this.blobExists(id)) {
            this.removeBlob(id);
        }
        this.$data.wprjFile.addBlob(buffer, id, options);
        return id;
    },

    addBlobFromData64Url: function(buffer, options) {
        throw new Error("NotImplementedError");            // FIXME
    },

    addBlobFromImage: function(buffer, options) {
        throw new Error("NotImplementedError");            // FIXME
    },

    addBlobFromUrl: function(buffer, callback, options) {
        setTimeout(function() {
            callback(new Error("NotImplementedError"));    // FIXME
        }, 0);
    },

    // FIXME

    getBlobMetadata: function(id) {
        return this.$data.wprjFile.getBlobRecord(id).metadata;
    },

    removeBlob: function(id) {
        this.$data.wprjFile.removeBlob(id);
        // Free blobs and blobs' URL
        if (this.$data.blobCache[id]) {
            if (this.$data.blobCache[id].url) {
                URL.revokeObjectURL(this.$data.blobCache[id].url);
            }
            if (this.$data.blobCache[id].blob && this.$data.blobCache[id].blob.close) {
                try {
                    this.$data.blobCache[id].blob.close();
                } catch (error) {
                    // pass
                }
            }
        }
    },

    getBlobList: function() {
        return this.$data.wprjFile.getBlobList();
    },

    blobExists: function(id) {
        return this.$data.wprjFile.blobExists(id);
    },

    serialize: function() {
        var serialized = this.$super();

        serialized.layers = {};
        for (var layerName in this.layers) {
            serialized.layers[layerName] = [];
            for (var i = 0 ; i < this.layers[layerName].length ; i++) {
                serialized.layers[layerName].push(this.layers[layerName][i].serialize());
            }
        }

        return serialized;
    },

    unserialize: function(serialized) {
        this.$super(serialized);

        for (var layerName in serialized.layers) {
            for (var i = 0 ; i < serialized.layers[layerName].length ; i++) {
                this.addStructure(this.$class.$unserialize(serialized.layers[layerName][i]), layerName);
            }
        }
    },

    _clean: function() {
        var structures = Object.getOwnPropertyNames(this.$data.structures);
        for (var i = 0 ; i < structures.length ; i++) {
            this.$data.structures[structures[i]].destroy();
        }
        this.$data.structures = {};
        this.$data.layers = {};
        // TODO remove blobs from blob cache
    }

});

SerializableClass.$register(ProjectManager);

module.exports = ProjectManager;
